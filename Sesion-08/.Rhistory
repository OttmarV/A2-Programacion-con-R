model_ar <- ar(ar1)
model_ar
acf(ar1)
# utilizamos ACR y PACF
par(mfrow = c(1,2))
acf(ar1)
pacf(ar1)
set.seed(2020)
ma1 <- arima.sim(model = list(order = c(0,0,2), ma = c(0.5)), n = 100)
ts_plot(ma1, title = 'Simulated MA1')
ma1 <- arima.sim(model = list(order = c(0,0,1), ma = c(0.5)), n = 100)
ts_plot(ma1, title = 'Simulated MA1')
md_ma <- arima(ma1, order = c(0,0,1))
md_ma
set.seed(2020)
ma2 <- arima.sim(model = list(order = c(0,0,2), ma = c(0.5,-0.4)), n = 200)
ts_plot(ma2, title = 'Simulated MA2')
md_ma <- arima(ma2, order = c(0,0,2))
md_ma
library(TSstudio)
Coffee_Prices
Coffee_Prices
head(Coffee_Prices)
str(cars)
str(cars)
# Sacamos la correlación entre velocidad y distancia
cor(cars$speed, cars$dist)
# Vemos una linea que suaviza la relación
scatter.smooth(x=cars$speed,
y=cars$dist,
main="Relacion distancia y velocidad")
# Ajustamos un modelo de regresión lineal
# en general: lm(y ~ x, data)
modlin <- lm(dist ~ speed, data=cars)
print(modlin)
summary(modlin)
print(modlin)
modlin$coefficients
# para una nueva velocidad (26)
x_new <- 26
y_new <- b_0 + b_1*x_new
print(y_new)
b_0 <- modlin$coefficients[1]
b_1 <- modlin$coefficients[2]
# para una nueva velocidad (26)
x_new <- 26
y_new <- b_0 + b_1*x_new
print(y_new)
abline(lm(speed ~ dist))
cars %>% abline(lm(speed ~ dist))
abline(lm(cars$speed ~ cars$dist))
abline(modlin)
head(mtcars)
str(mtcars)
head(mtcars)
head(mtcars)
library(ggplot2)
ggplot(cars, aes(dist, speed)) +
geom_point() +
stat_smooth(method = lm)
library(ggplot2)
ggplot(cars, aes(dist, speed)) +
geom_point() +
stat_smooth(method = lm)
ggplot(cars, aes(dist, speed)) +
geom_point() +
stat_smooth(method = lm)
library(ggplot2)
ggplot(cars, aes(dist,speed)) + geom_point() + stat_smooth(method = lm)
head(iris)
str(iris)
# Generamos números aleatorios de tamaño 0.8*tamaño iris
set.seed(2020)
random <- sample(1:nrow(iris), 0.8 * nrow(iris))
random
# Generamos números aleatorios de tamaño 0.8*tamaño iris
set.seed(2020)
random <- sample(1:nrow(iris), 0.8 * nrow(iris))
random
# Normalizamos (ie pasamos todo a que este entre 0 y 1)
normalizado <- function(x) {
normalized_x <- (x -min(x))/(max(x)-min(x))
normalized_x
}
# Aplicamos la funcion a las columnas que son numéricas
# y lo guardamos como un data frame
iris_normalizado <- as.data.frame(lapply(iris[,c(1,2,3,4)],
normalizado))
head(iris)
head(iris_normalizado)
# train: x's
iris_train <- iris_normalizado[random,]
# test: x's
iris_test <- iris_normalizado[-random,]
# train: y's
iris_categoria_train <- iris[random,5]
# test: y's
iris_categoria_test <- iris[-random,5]
# algoritmo knn
model_knn <- knn(train = iris_train,
cl=iris_categoria_train,
k=3)
# install.packages('class')
library(class)
# algoritmo knn
model_knn <- knn(train = iris_train,
cl=iris_categoria_train,
k=3)
# Generamos números aleatorios de tamaño 0.8*tamaño iris
set.seed(2020)
random <- sample(1:nrow(iris), 0.8 * nrow(iris))
# Normalizamos (ie pasamos todo a que este entre 0 y 1)
normalizado <- function(x) {
normalized_x <- (x -min(x))/(max(x)-min(x))
normalized_x
}
# Aplicamos la funcion a las columnas que son numéricas
# y lo guardamos como un data frame
iris_normalizado <- as.data.frame(lapply(iris[,c(1,2,3,4)],
normalizado))
# train: x's
iris_train <- iris_normalizado[random,]
# test: x's
iris_test <- iris_normalizado[-random,]
# train: y's
iris_categoria_train <- iris[random,5]
# test: y's
iris_categoria_test <- iris[-random,5]
# install.packages('class')
library(class)
# algoritmo knn
model_knn <- knn(train = iris_train,
cl=iris_categoria_train,
k=3)
# algoritmo knn
model_knn <- knn(train = iris_train,
test = iris_test,
cl=iris_categoria_train,
k=3)
# algoritmo knn
model_knn <- knn(train = iris_train,
test = iris_test,
cl=iris_categoria_train,
k=3)
# algoritmo knn
model_knn <- knn(train = iris_train,
test = iris_test,
cl=iris_categoria_train,
k=8)
model_knn
iris_test
iris_categoria_test
model_knn
# algoritmo knn
model_knn <- knn(train = iris_train,
test = iris_test,
cl=iris_categoria_train,
k=2)
#matriz de confusion
con_mat <- table(model_knn,iris_categoria_test)
con_mat
# algoritmo knn
model_knn <- knn(train = iris_train,
test = iris_test,
cl=iris_categoria_train,
k=3)
model_knn
#matriz de confusion
con_mat <- table(model_knn,iris_categoria_test)
con_mat
iris_train
head(iris_train)
library(ggplot2)
diamantes <- data.frame(diamonds)
random <- sample(1:nrow(diamantes),0.9 * nrow(diamantes))
normalizado <-function(x) { (x -min(x))/(max(x)-min(x))}
diamantes_normalizado <- as.data.frame(lapply(diamantes[,c(1,5,6,7,8,9,10)], normalizado))
diamantes_trainining <- diamantes_normalizado[random,]
diamantes_test <- diamantes_normalizado[-random,]
diamantes_categoria_target <- as.factor(diamantes[random,2])
diamantes_categoria_test <- as.factor(diamantes[-random,2])
diamantes
diamantes <- data.frame(diamonds)
random <- sample(1:nrow(diamantes),0.9 * nrow(diamantes))
normalizado <-function(x) { (x -min(x))/(max(x)-min(x))}
diamantes_normalizado <- as.data.frame(lapply(diamantes[,c(1,5,6,7,8,9,10)], normalizado))
diamantes_trainining <- diamantes_normalizado[random,]
diamantes_test <- diamantes_normalizado[-random,]
diamantes_categoria_target <- as.factor(diamantes[random,2])
diamantes_categoria_test <- as.factor(diamantes[-random,2])
library(class)
predic <- knn(diamantes_trainining,
diamantes_test,
cl=diamantes_categoria_target,k=20)
con_mat <- table(predic,diamantes_categoria_test)
con_mat
iiag(con_mat)
diag(con_mat)
sum(diag(con_mat))
con_mat
diag(con_mat)
sum(diag(con_mat))
nrow(con_mat)
nrow(diamantes_test)
sum(diag(con_mat))/nrow(diamantes_test)
# Cargamos la data de muestra Airpassangers
# Tiene total de pasajeros mensuales entre 1949 y 1960
air <- AirPassengers
# Veamos air, ¿cómo lo leerías?
air
# Vemos que es de la clase ts (time series)
class(air)
# Caracteristicas de la serie
start(air) # (year, month)
end(air) # (year, mont)
frequency(air)
# Estadísticos básicos
summary(air)
# Podemos dibujar esta informacion en una linea de tiempo con la funcion plot()
#par('mar')
#par(mar = rep(2, 4))
plot(air, main = 'Total de pasajeros mensuales')
# Podemos dibujar esta informacion en una linea de tiempo con la funcion plot()
par('mar')
par(mar = rep(2, 4))
plot(air, main = 'Total de pasajeros mensuales')
rep(2,4)
#install.packages('TSstudio')
library(TSstudio)
?USUnRate
class(USUnRate)
start(USUnRate)
end(USUnRate)
plot(USUnRate, main = 'Unemployment Rate in USA')
# Seasonal vs Cycle
ts_heatmap(USUnRate) #Cycle
# Seasonal vs Cycle
ts_heatmap(USUnRate) #Cycle
ts_heatmap(USgas)    #Seasonal
plot(USgas, main = 'US Gas Consumption')
plot(USgas, main = 'US Gas Consumption')
ts_plot(USUnRate)
library(TSstudio)
AirPassengers
ts_plot(AirPassengers)
# Using log to remove the multiplicative effect
log(AirPassengers)
ts_plot(log(AirPassengers))
# Differenciate the ts so we take away the trend
diff(AirPassengers, lag = 1)
AirPassengers
ts_plot(diff(AirPassengers, lag = 1))
# Use both techniques
ts_plot(diff(log(AirPassengers), lag = 1))
ts_plot(USgas)
set.seet(2020)
set.seed(2020)
ar1 <- arima.sim(model = list(order = c(1,0,0),
ar = c(0.9)),
n = 100)
ts_plot(ar1, title = 'Autoregressive process')
ts_plot(ar1, title = 'Autoregressive process')
# estimamos coeficientes
model_ar <- ar(ar1)
model_ar
# estimamos coeficientes
model_ar <- ar(ar1)
model_ar
set.seed(2020)
ma2 <- arima.sim(model = list(order = c(0,0,2), ma = c(0.5,-0.4)), n = 200)
ts_plot(ma2, title = 'Simulated MA2')
ma2 <- arima.sim(model = list(order = c(0,0,2), ma = c(0.5,-0.4)), n = 200)
ts_plot(ma2, title = 'Simulated MA2')
md_ma <- arima(ma2, order = c(0,0,2))
md_ma
arima.sim(model = list(order = c(2,0,2), ma = c(0.5,-0.4)),ar = c(0.1,0.1), n = 200)
arima.sim(model = list(order = c(1,0,2), ma = c(0.5,-0.4)),ar = c(0.7), n = 200)
arima.sim(model = list(order = c(1,0,2),ar = c(0.7),, ma = c(0.5,-0.4)) n = 200)
arima.sim(model = list(order = c(1,0,2),ar = c(0.7),, ma = c(0.5,-0.4), n = 200)
arima.sim(model = list(order = c(1,0,2),ar = c(0.7),, ma = c(0.5,-0.4), n = 200))
ts_plot(ma2, title = 'Simulated MA2')
arima.sim(model = list(order = c(1,0,2),ar = c(0.7),, ma = c(0.5,-0.4), n = 200))
ts_plot(ma2, title = 'Simulated ARMA(1,0,2)')
arima.sim(model = list(order = c(1,0,2),ar = c(0.7), ma = c(0.5,-0.4), n = 200))
ts_plot(ma2, title = 'Simulated ARMA(1,0,2)')
arima.sim(model = list(order = c(1,0,2),ar = c(0.7), ma = c(0.5,-0.4)), n = 200)
ts_plot(ma2, title = 'Simulated ARMA(1,0,2)')
arima(ma3, order = c(1,0,2))
ma3 <- arima.sim(model = list(order = c(1,0,2),ar = c(0.7), ma = c(0.5,-0.4)), n = 200)
ts_plot(ma2, title = 'Simulated ARMA(1,0,2)')
arima(ma3, order = c(1,0,2))
arima(ma3, order = c(2,0,1))
arima(ma3, order = c(2,0,1))
Coffee_Prices
str(Coffee_Prices)
# Seleccionamos solo el tipo de café Robusta
Coffee_Prices[,'Robusta']
# Seleccionamos solo el tipo de café Robusta
CoffePrice_ts <- Coffee_Prices[,'Robusta']
# Seleccionamos solo el tipo de café Robusta
CoffeePrice_Robusta <- Coffee_Prices[,'Robusta']
plot_ts(CoffePrice_Robusta)
ts_plot(CoffePrice_Robusta)
class(CoffeePrice_Robusta)
ts_plot(CoffePrice_Robusta)
ts_plot(CoffeePrice_Robusta)
ts_plot(CoffeePrice_Robusta,title = 'Precio de Cafe Robusta Mensual')
diff(CoffeePrice_Robusta)
CoffePrice_Robusta_1990 <- window(CoffeePrice_Robusta, start = (1990,1))
CoffePrice_Robusta_1990 <- window(CoffeePrice_Robusta, start = c(1990,1))
CoffePrice_Robusta_1990
diff(CoffeePrice_Robusta_1990)
CoffePrice_Robusta_1990 <- window(CoffeePrice_Robusta, start = c(1990,1))
diff(CoffeePrice_Robusta_1990)
CoffeePrice_Robusta_1990 <- window(CoffeePrice_Robusta, start = c(1990,1))
diff(CoffeePrice_Robusta_1990)
CoffePrice_Diff <- diff(CoffeePrice_Robusta_1990)
# Ajusta un modelo ARIMA p= 1, d = 1, q=0 y guardalo en arima_fit
arima_fit <- arima(CoffeePrice_Robusta_1990, order = c(1,1,0))
arima_fit
# Proceso ARIMA
# La diferencia entre ARMA y ARIMA es que en ARIMA podemos
# tener series no estacionarias
library(TSstudio)
# Seleccionamos solo el tipo de café Robusta
CoffeePrice_Robusta <- Coffee_Prices[,'Robusta']
# ¿Es ts?
class(CoffeePrice_Robusta)
# Gráfica
ts_plot(CoffeePrice_Robusta,title = 'Precio de Cafe Robusta Mensual')
# Nos quedamos de 1990+
CoffeePrice_Robusta_1990 <- window(CoffeePrice_Robusta,
start = c(1990,1))
# ¿Qué hace la función diff?
diff(CoffeePrice_Robusta_1990)
# Ajusta un modelo ARIMA p= 1, d = 1, q=0 y guardalo en arima_fit
arima_fit <- arima(CoffeePrice_Robusta_1990, order = c(1,1,0))
# Ver el summary del fit
summary(arima_fit)
# Utiliza tu modelo y la funcion forecast para predecir 5 puntos
forecast(arima_fit, n =1)
# Seleccionamos solo el tipo de café Robusta
CoffeePrice_Robusta <- Coffee_Prices[,'Robusta']
# Proceso ARIMA
# La diferencia entre ARMA y ARIMA es que en ARIMA podemos
# tener series no estacionarias
library(TSstudio)
# Seleccionamos solo el tipo de café Robusta
CoffeePrice_Robusta <- Coffee_Prices[,'Robusta']
install.packages('shiny')
runExample("01_hello")      # a histogram
library(shiny)
runExample("01_hello")      # a histogram
runExample("02_text")       # tables and data frames
runExample("01_hello")      # a histogram
runExample("02_text")       # tables and data frames
runExample("03_reactivity") # a reactive expression
runExample("04_mpg")        # global variables
runExample("05_sliders")    # slider bars
runExample("06_tabsets")    # tabbed panels
runExample("07_widgets")    # help text and submit buttons
runExample("08_html")       # Shiny app built from HTML
runExample("09_upload")     # file upload wizard
runExample("11_timer")      # an automated timer
runExample("11_timer")      # an automated timer
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
View(ui)
View(ui)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
# Paquete shiny
# Objetivo: construir web applications interactivas, tambien llamadas apps
install.packages('shiny')
install.packages("shiny")
# Veamos un ejemplo precargado
runExample("01_hello")
#install.packages('shiny')
library(shiny)
# Veamos un ejemplo precargado
runExample("01_hello")
runExample('02_text')
runExample('07_widgets')
runExample('05_sliders')
runExample('05_sliders')
# Veamos un ejemplo precargado
runExample("01_hello")
runExample('02_text')
runExample('02_text')
# Veamos un ejemplo precargado
runExample("01_hello")
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
bins <- seq(min(x), max(x), length.out = 31)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
par(mar=c(1,1,1,1))
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
# Veamos un ejemplo precargado
runExample("01_hello")
# Veamos un ejemplo precargado
runExample("01_hello")
library(shiny)
# App en blanco
ui <- fluidPage(
)
server <- function(input, output) {
}
shinyApp(ui = ui, server = server)
# App básica
ui <- fluidPage(
titlePanel("Titulo 2"),
h1('Título 1'),
h2("Título 2, igual a arriba"),
sidebarLayout(
sidebarPanel("Panel lateral"),
mainPanel("Panel principal",
p("p creates a paragraph of text."),
p("A new p() command starts a new paragraph. Supply a style attribute to change the format of the entire paragraph.", style = "font-family: 'times'; font-si16pt"),
strong("strong() makes bold text."),
em("em() creates italicized (i.e, emphasized) text."),
br(),
code("code displays your text similar to computer code"),
div("div creates segments of text with a similar style. This division of text is all blue because I passed the argument 'style = color:blue' to div", style = "color:blue"),
br(),
p("span does the same thing as div, but it works with",
span("groups of words", style = "color:blue"),
"that appear inside a paragraph.")),
position ='right'
)
)
server <- function(input, output) {
}
shinyApp(ui = ui, server = server)
runApp('C:/Users/AnaLuisaOrtegaRenter/Desktop/BEDU_Student/BEDU_Student/IntroShiny/Parte03-Formato.R')
runExample('02_text')
runExample('02_text')
# Widgets: herramientas para interactuar con usuario
library(shiny)
?selectInput
library(shiny)
?selectInput
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
selectInput(inputId = "var",
label = "Destino",
choices = c("Playa",
"Pueblo Mágico",
"Ciudad"),
selected = "Pueblo Mágico")
),
mainPanel(
textOutput("input_selected")
)
)
)
server <- function(input, output) {
output$input_selected <- renderText({
paste0('Seleccionaste: ', input$var)
})
}
shinyApp(ui = ui, server = server)
# Reto 03: Utiliza sliderInput para poner un rango que vaya desde el 1 hasta el 12
?sliderInput
library(shiny)
runApp('primerapp')
library(shiny)
runApp('primerapp')
getwd()
setwd('C:/Users/AnaLuisaOrtegaRenter/Desktop/BEDU_Student/BEDU_Student/IntroShiny')
runApp('primerapp')
runApp('primerapp')
getwd()
